<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Limestone | Reading</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/reading.css') }}">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
</head>
<body>
  <!-- Fixed exit (same size as bookshelf icons, no shadow) -->
  <a class="exit-btn-fixed" href="{{ url_for('bookshelf') }}" title="Back to shelf">
    <img src="{{ url_for('static', filename='img/exit.png') }}" alt="Exit">
  </a>

  <div class="reader-shell">
    <!-- Top bar (tools) -->
    <header class="topbar">
      <div class="bar-inner">
        <button id="btnTextBox" class="tool-btn" title="Text box">
          <img src="{{ url_for('static', filename='img/text_box.png') }}" alt="T">
        </button>
        <button id="btnHighlighter" class="tool-btn" title="Highlighter">
          <img src="{{ url_for('static', filename='img/highlighter.png') }}" alt="Highlighter">
        </button>
        <button id="btnDrawer" class="tool-btn" title="Thin pen">
          <img src="{{ url_for('static', filename='img/drawer.png') }}" alt="Pen">
        </button>
      </div>
    </header>

    <div class="layout">
      <!-- Ask AI (left) -->
      <aside class="askai">
        <pre id="aiOut" class="ai-out"></pre>
        <form id="aiForm" class="ai-form">
          <div class="ai-input">
            <input type="text" name="q" placeholder="Ask AI…" autocomplete="off">
            <button type="submit" class="icon-btn" title="Ask">
              <img src="{{ url_for('static', filename='img/search.png') }}" alt="Ask">
            </button>
          </div>
        </form>
      </aside>

{% if file_url %}
      <!-- Middle: digital reader -->
      <main class="book-area with-file" data-tool="none">
        <div id="pdfScroll" class="pdf-scroll">
          <div id="pdfPages" class="pdf-pages"></div>

          <!-- Templates for per-page overlays and text boxes -->
          <template id="tplOverlay">
            <div class="overlay-layer">
              <canvas class="draw-canvas" data-page=""></canvas>
            </div>
          </template>

          <template id="tplTextbox">
            <div class="textbox">
              <div class="tb-handle" title="Drag to move"></div>
              <div class="tb-content" contenteditable="true" spellcheck="false"></div>
            </div>
          </template>
        </div>

        <!-- Footer controls: Undo / Clear page / Save -->
        <form class="progress-bar" method="post" action="{{ url_for('update_progress', book_id=book.id) }}">
          <div class="controls-left">
            <button type="button" id="btnUndo" class="btn-ghost">Undo</button>
            <button type="button" id="btnClear" class="btn-ghost">Clear page</button>
          </div>
          <label>
            Page
            <input id="pageInput" type="number" name="page" min="0" value="{{ current_page or 0 }}" inputmode="numeric">
            {% if total_pages %}/ {{ total_pages }}{% endif %}
          </label>
          <button class="btn-save" type="submit">Save</button>
        </form>
      </main>
{% else %}
      <!-- Middle: physical book info -->
      <main class="book-area no-file">
        <div class="no-file-msg">
          <img class="cover-preview" src="{{ cover_url }}" alt="Cover">
          <p>This is a <b>Physical</b> book. Use the Notes pane to record pages and thoughts.</p>
          <form class="progress-bar" method="post" action="{{ url_for('update_progress', book_id=book.id) }}">
            <div class="controls-left">
              <button type="button" id="btnUndo" class="btn-ghost" disabled>Undo</button>
              <button type="button" id="btnClear" class="btn-ghost" disabled>Clear page</button>
            </div>
            <label>Page <input type="number" name="page" min="0" value="{{ current_page or 0 }}" inputmode="numeric"></label>
            <button class="btn-save" type="submit">Save</button>
          </form>
        </div>
      </main>
{% endif %}

      <!-- Notes (right) -->
      <aside class="notes{% if not file_url %} expanded{% endif %}">
        <div class="notes-page-num" id="notesPageLabel">
          Page {{ current_page or 0 }}
        </div>

        <form id="noteForm" class="note-form" method="post" action="{{ url_for('add_note', book_id=book.id) }}">
          <div class="row">
            <input class="note-title" type="text" name="title" placeholder="Title">
            <input class="note-page"  type="number" name="page" min="0" placeholder="Page #" value="{{ current_page or 0 }}">
          </div>
          <textarea class="note-text" name="text" rows="6" placeholder="Enter text from here."></textarea>
        </form>
      </aside>
    </div>
  </div>

  <div id="pageHud" class="page-hud">– / –</div>

  <script>
    // --- Ask AI (stub passthrough) ---
    (function(){
      const f = document.getElementById('aiForm');
      const out = document.getElementById('aiOut');
      if (!f) return;
      f.addEventListener('submit', async (e) => {
        e.preventDefault();
        const fd = new FormData(f);
        out.textContent = 'Thinking…';
        try{
          const res = await fetch('{{ url_for("ask_ai") }}', { method:'POST', body:fd });
          const data = await res.json();
          out.textContent = data.ok ? data.answer : 'Error.';
        }catch(_){ out.textContent = 'Error.'; }
      });
    })();

    function debounce(fn, ms){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms); }; }

    {% if file_url %}
    // ================= PDF Viewer + Tools + Undo/Clear =================
    (function(){
      const pdfjsLib = window['pdfjs-dist/build/pdf'];
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

      const url = "{{ file_url }}";
      const pagesHost = document.getElementById('pdfPages');
      const scrollEl  = document.getElementById('pdfScroll');
      const hud       = document.getElementById('pageHud');
      const pageInput = document.getElementById('pageInput');

      const tplOverlay = document.getElementById('tplOverlay');
      const tplTextbox = document.getElementById('tplTextbox');

      const btnUndo  = document.getElementById('btnUndo');
      const btnClear = document.getElementById('btnClear');

      const TOOL = { NONE:'none', BOX:'box', HIGHLIGHT:'highlighter', DRAW:'drawer' };
      const state = {
        tool: TOOL.NONE,
        pdf: null,
        total: {{ (total_pages or 'null') }},
        current: {{ (current_page or 1) }},
        posting: false,
        overlays: new Map(), // page -> { layer, canvas, ctx, w, h, pageDiv }
        undo: new Map()      // page -> [{kind:'stroke'|'box', id, localNode?}]
      };

      // Ink settings: constant opacity/width; highlighter = flat bar ends
      const INK = {
        highlighterRGBA: 'rgba(15,53,36,0.25)',
        penColor: '#123E2A',
        highlighterWidth: 20, // one-bar look
        penWidth: 3          // drawer slightly thicker
      };

      // --- Toolbar (mode selection) ---
      const btnBox  = document.getElementById('btnTextBox');
      const btnHi   = document.getElementById('btnHighlighter');
      const btnDraw = document.getElementById('btnDrawer');

      function setTool(t){
        state.tool = t;
        document.querySelectorAll('.tool-btn').forEach(b=>b.classList.remove('active'));
        scrollEl.classList.remove('textbox-mode','highlight-mode','draw-mode');
        if (t === TOOL.BOX){ btnBox.classList.add('active'); scrollEl.classList.add('textbox-mode'); }
        if (t === TOOL.HIGHLIGHT){ btnHi.classList.add('active'); scrollEl.classList.add('highlight-mode'); }
        if (t === TOOL.DRAW){ btnDraw.classList.add('active'); scrollEl.classList.add('draw-mode'); }
      }
      btnBox .addEventListener('click', ()=> setTool(state.tool===TOOL.BOX?TOOL.NONE:TOOL.BOX));
      btnHi  .addEventListener('click', ()=> setTool(state.tool===TOOL.HIGHLIGHT?TOOL.NONE:TOOL.HIGHLIGHT));
      btnDraw.addEventListener('click', ()=> setTool(state.tool===TOOL.DRAW?TOOL.NONE:TOOL.DRAW));

      // --- Notes binding & progress ---
      const noteForm = document.getElementById('noteForm');
      const noteTitle = noteForm.querySelector('.note-title');
      const notePage  = noteForm.querySelector('.note-page');
      const noteText  = noteForm.querySelector('.note-text');
      const pageLabel = document.getElementById('notesPageLabel');

      let noteDirty = false;
      let activeNotePage = state.current || 1;

      function hudSet(p, t){ hud.textContent = t ? (p + ' / ' + t) : (String(p) + ' / –'); }
      function setLabel(p){ if (pageLabel){ pageLabel.textContent = 'Page ' + p; } }
      function setNotePage(p){ notePage.value = p; setLabel(p); }

      async function loadNoteFor(page){
        try{
          const q = new URLSearchParams({ page: String(page) });
          const res = await fetch(`/api/books/{{ book.id }}/notes/by_page?` + q.toString());
          const data = await res.json();
          if (data.ok){
            const n = data.note;
            noteTitle.value = n ? (n.title || '') : '';
            noteText.value  = n ? (n.text  || '') : '';
            noteDirty = false;
            activeNotePage = page;
            setNotePage(page);
          }
        }catch(_){}
      }
      async function saveNoteFor(page){
        if (!noteDirty) return;
        try{
          const payload = { page, title: noteTitle.value || '', text: noteText.value || '' };
          await fetch(`/api/books/{{ book.id }}/notes/upsert_by_page`, {
            method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload)
          });
          noteDirty = false;
        }catch(_){}
      }
      noteTitle.addEventListener('input', ()=>{ noteDirty = true; });
      noteText .addEventListener('input', ()=>{ noteDirty = true; });

      async function postProgress(p, t){
        if (state.posting) return;
        state.posting = true;
        try{
          await fetch(`/api/books/{{ book.id }}/progress`, {
            method: 'POST', headers: {'Content-Type':'application/json'},
            body: JSON.stringify({page: p, total: t})
          });
        }catch(_){}
        state.posting = false;
      }
      const postDebounced = debounce(postProgress, 350);

      // --- Page visibility / scrolling ---
      function visiblePage(){
        const items = pagesHost.querySelectorAll('.pdf-page');
        let bestId = 1, bestRatio = -1;
        const vh = scrollEl.getBoundingClientRect();
        items.forEach(div => {
          const r = div.getBoundingClientRect();
          const overlapX = Math.max(0, Math.min(vh.right, r.right) - Math.max(vh.left, r.left));
          const overlapY = Math.max(0, Math.min(vh.bottom, r.bottom) - Math.max(vh.top, r.top));
          const area = overlapX * overlapY;
          const totalArea = r.width * r.height || 1;
          const ratio = area / totalArea;
          const id = parseInt(div.dataset.page, 10) || 1;
          if (ratio > bestRatio){ bestRatio = ratio; bestId = id; }
        });
        return bestId;
      }
      async function onScroll(){
        const p = visiblePage();
        if (p !== state.current){
          await saveNoteFor(activeNotePage);
          state.current = p;
          hudSet(state.current, state.total);
          if (pageInput) pageInput.value = state.current;
          postDebounced(state.current, state.total);
          await loadNoteFor(state.current);
        }
      }

      // --- Overlay bootstrap + input handlers ---
      function ensureOverlayFor(pageDiv, pageNum){
        if (state.overlays.has(pageNum)) return state.overlays.get(pageNum);
        const frag = tplOverlay.content.cloneNode(true);
        const layer  = frag.querySelector('.overlay-layer');
        const canvas = frag.querySelector('.draw-canvas');
        canvas.dataset.page = String(pageNum);
        pageDiv.appendChild(frag);

        const ctx = canvas.getContext('2d');
        const entry = { layer, canvas, ctx, w:0, h:0, pageDiv };
        state.overlays.set(pageNum, entry);

        // ------ Freehand drawing (hi/drawer) ------
        let drawing = false;
        let last = null;
        let points = [];

        function toCanvasXY(evt){
          const r = canvas.getBoundingClientRect();
          return { x: evt.clientX - r.left, y: evt.clientY - r.top };
        }
        function pushPoint(pt){ points.push([pt.x/entry.w, pt.y/entry.h]); }

        function strokeSegment(from, to){
          const isHi = (state.tool === TOOL.HIGHLIGHT);
          const c = entry.ctx;
          c.lineCap = isHi ? 'butt' : 'round'; // marker bar vs pen
          c.lineJoin = 'round';
          c.strokeStyle = isHi ? INK.highlighterRGBA : INK.penColor;
          c.lineWidth   = isHi ? INK.highlighterWidth : INK.penWidth;
          c.globalAlpha = 1;
          c.globalCompositeOperation = 'source-over';
          c.beginPath();
          c.moveTo(from.x, from.y);
          c.lineTo(to.x, to.y);
          c.stroke();
        }

        canvas.addEventListener('mousedown', (e)=>{
          if (state.tool !== TOOL.HIGHLIGHT && state.tool !== TOOL.DRAW) return;
          drawing = true; last = toCanvasXY(e); points = []; pushPoint(last); e.preventDefault();
        });
        window.addEventListener('mousemove', (e)=>{
          if (!drawing) return;
          const cur = toCanvasXY(e);
          strokeSegment(last, cur);
          last = cur; pushPoint(cur);
        });
        window.addEventListener('mouseup', async ()=>{
          if (!drawing) return; drawing = false; last = null;
          if (points.length >= 2){
            const payload = {
              tool: state.tool === TOOL.HIGHLIGHT ? 'highlighter' : 'drawer',
              width: state.tool === TOOL.HIGHLIGHT ? INK.highlighterWidth : INK.penWidth,
              color: state.tool === TOOL.HIGHLIGHT ? INK.highlighterRGBA : INK.penColor,
              points: JSON.stringify(points)
            };
            try{
              const res  = await fetch(`/api/books/{{ book.id }}/pages/${pageNum}/strokes`, {
                method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload)
              });
              const data = await res.json();
              if (data.ok){ pushUndo(pageNum, { kind:'stroke', id:data.id }); }
            }catch(_){}
          }
        });

        // ------ Click to add textbox ------
        pageDiv.addEventListener('click', async (e)=>{
          if (state.tool !== TOOL.BOX) return;

          // Don’t spawn a new box when clicking an existing one or its handle
          const existing = e.target.closest('.textbox');
          if (existing || e.target.closest('.tb-handle') || (existing && existing.dataset.dragging)) return;

          const r = pageDiv.getBoundingClientRect();
          const x = (e.clientX - r.left) / r.width;
          const y = (e.clientY - r.top)  / r.height;

          const box  = tplTextbox.content.firstElementChild.cloneNode(true);
          const wPct = 0.25, hPct = 0.12;
          box.style.left   = (x*100)+'%';
          box.style.top    = (y*100)+'%';
          box.style.width  = (wPct*100)+'%';
          box.style.height = (hPct*100)+'%';
          pageDiv.appendChild(box);

          try{
            const res  = await fetch(`/api/books/{{ book.id }}/pages/${pageNum}/boxes`,{
              method:'POST', headers:{'Content-Type':'application/json'},
              body: JSON.stringify({ x, y, w:wPct, h:hPct, text:'' })
            });
            const data = await res.json();
            if (data.ok){
              box.dataset.annId = data.id;
              enableBoxEditing(box, pageNum, data.id);
              box.querySelector('.tb-content')?.focus();
              pushUndo(pageNum, { kind:'box', id:data.id, localNode:box });
            }else{
              box.remove();
            }
          }catch(_){ box.remove(); }
        });

        return entry;
      }

      // --- Undo/Clear ---
      function pushUndo(page, item){
        if (!state.undo.has(page)) state.undo.set(page, []);
        state.undo.get(page).push(item);
      }
      async function doUndo(){
        const page = state.current || 1;
        const stack = state.undo.get(page) || [];
        const last = stack.pop();
        if (!last) return;
        if (last.kind === 'stroke'){
          try{
            await fetch(`/api/books/{{ book.id }}/pages/${page}/strokes/${last.id}`, { method:'DELETE' });
            await redrawStrokes(page);
          }catch(_){}
        }else if (last.kind === 'box'){
          if (last.localNode && last.localNode.remove) last.localNode.remove();
          try{
            await fetch(`/api/books/{{ book.id }}/pages/${page}/boxes/${last.id}`, { method:'DELETE' });
          }catch(_){}
        }
      }

      async function clearPage(){
        const page = state.current || 1;
        const entry = state.overlays.get(page);
        if (!entry) return;
        try{
          const sRes = await fetch(`/api/books/{{ book.id }}/pages/${page}/strokes`);
          const sData = await sRes.json();
          if (sData.ok){
            for (const s of sData.strokes){
              await fetch(`/api/books/{{ book.id }}/pages/${page}/strokes/${s.id}`, { method:'DELETE' });
            }
          }
          const bRes = await fetch(`/api/books/{{ book.id }}/pages/${page}/boxes`);
          const bData = await bRes.json();
          if (bData.ok){
            for (const b of bData.boxes){
              await fetch(`/api/books/{{ book.id }}/pages/${page}/boxes/${b.id}`, { method:'DELETE' });
            }
          }
        }catch(_){}
        await redrawStrokes(page);
        entry.pageDiv.querySelectorAll('.textbox').forEach(n=>n.remove());
        state.undo.set(page, []);
      }

      if (btnUndo)  btnUndo.addEventListener('click', (e)=>{ e.preventDefault(); doUndo(); });
      if (btnClear) btnClear.addEventListener('click', async (e)=>{ e.preventDefault(); await clearPage(); });

      // --- Textbox editing/dragging (handle + optional Alt-drag anywhere) ---
      function enableBoxEditing(boxEl, pageNum, annId){
        const contentEl = boxEl.querySelector('.tb-content');
        const handleEl  = boxEl.querySelector('.tb-handle');

        // Save text (debounced + blur)
        let t;
        function saveText(){
          const text = contentEl.innerText || '';
          fetch(`/api/books/{{ book.id }}/pages/${pageNum}/boxes/${annId}`, {
            method:'PUT', headers:{'Content-Type':'application/json'},
            body: JSON.stringify({ text })
          }).catch(()=>{});
        }
        contentEl.addEventListener('input', ()=>{ clearTimeout(t); t=setTimeout(saveText,300); });
        contentEl.addEventListener('blur', saveText);

        // Drag to move (handle, or Alt/Option anywhere on the box)
        let dragging=false, start={x:0,y:0}, startRect=null, parentRect=null;

        function startDrag(e){
          const allow = e.target === handleEl || e.altKey;
          if (!allow || e.button !== 0) return;
          e.preventDefault(); e.stopPropagation();
          dragging=true; boxEl.classList.add('dragging'); document.body.style.userSelect='none';
          parentRect = boxEl.parentElement.getBoundingClientRect();
          startRect  = boxEl.getBoundingClientRect();
          start.x = e.clientX; start.y = e.clientY;
          boxEl.dataset.dragging = '1';
        }
        function onMove(e){
          if (!dragging) return;
          const dx = e.clientX - start.x, dy = e.clientY - start.y;
          const nx = (startRect.left + dx - parentRect.left) / parentRect.width;
          const ny = (startRect.top  + dy - parentRect.top ) / parentRect.height;
          const clampedX = Math.max(0, Math.min(0.98, nx));
          const clampedY = Math.max(0, Math.min(0.98, ny));
          boxEl.style.left = (clampedX*100)+'%';
          boxEl.style.top  = (clampedY*100)+'%';
        }
        function endDrag(){
          if (!dragging) return;
          dragging=false; boxEl.classList.remove('dragging'); document.body.style.userSelect='';
          setTimeout(()=>{ delete boxEl.dataset.dragging; }, 0);
          // persist final position
          const r = boxEl.getBoundingClientRect();
          const p = boxEl.parentElement.getBoundingClientRect();
          const nx = (r.left - p.left) / p.width;
          const ny = (r.top  - p.top ) / p.height;
          fetch(`/api/books/{{ book.id }}/pages/${pageNum}/boxes/${annId}`, {
            method:'PUT', headers:{'Content-Type':'application/json'},
            body: JSON.stringify({ x:nx, y:ny })
          }).catch(()=>{});
        }

        handleEl.addEventListener('mousedown', startDrag);
        boxEl.addEventListener('mousedown', (e)=>{ if (e.altKey) startDrag(e); });
        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup',   endDrag);
      }

      // --- Render helpers ---
      function pageContainer(num){
        const wrap = document.createElement('div');
        wrap.className = 'pdf-page';
        wrap.dataset.page = String(num);
        const canvas = document.createElement('canvas');
        canvas.style.display = 'block';
        canvas.style.width = '100%';
        canvas.style.height = 'auto';
        wrap.appendChild(canvas);
        return {wrap, canvas};
      }

      async function renderPage(num){
        const page = await state.pdf.getPage(num);
        const {wrap, canvas} = pageContainer(num);
        pagesHost.appendChild(wrap);

        const viewport = page.getViewport({ scale: 1.5 });
        const ctx = canvas.getContext('2d');
        canvas.height = viewport.height;
        canvas.width  = viewport.width;
        await page.render({canvasContext: ctx, viewport}).promise;

        // Overlay after rendering, matching size
        const entry = ensureOverlayFor(wrap, num);
        entry.canvas.width  = canvas.width;
        entry.canvas.height = canvas.height;
        entry.w = canvas.width; entry.h = canvas.height;

        await redrawStrokes(num);
        await redrawBoxes(num, wrap);
      }

      async function redrawStrokes(pageNum){
        const entry = state.overlays.get(pageNum);
        if (!entry) return;
        entry.ctx.clearRect(0,0,entry.w,entry.h);
        try{
          const res = await fetch(`/api/books/{{ book.id }}/pages/${pageNum}/strokes`);
          const data = await res.json();
          if (!data.ok) return;
          for (const s of data.strokes){
            const pts = JSON.parse(s.points || '[]');
            const isHi = (s.tool === 'highlighter');
            const c = entry.ctx;
            c.lineCap   = isHi ? 'butt' : 'round';
            c.lineJoin  = 'round';
            c.strokeStyle = isHi ? INK.highlighterRGBA : INK.penColor;
            c.lineWidth   = isHi ? INK.highlighterWidth : INK.penWidth;
            c.globalAlpha = 1;
            c.globalCompositeOperation = 'source-over';
            c.beginPath();
            for (let i=1;i<pts.length;i++){
              const p0 = { x: pts[i-1][0]*entry.w, y: pts[i-1][1]*entry.h };
              const p1 = { x: pts[i][0]*entry.w,   y: pts[i][1]*entry.h   };
              c.moveTo(p0.x, p0.y);
              c.lineTo(p1.x, p1.y);
            }
            c.stroke();
          }
        }catch(_){}
      }

      async function redrawBoxes(pageNum, pageDiv){
        pageDiv.querySelectorAll('.textbox').forEach(n=>n.remove());
        try{
          const res = await fetch(`/api/books/{{ book.id }}/pages/${pageNum}/boxes`);
          const data = await res.json();
          if (!data.ok) return;
          for (const b of data.boxes){
            const box = tplTextbox.content.firstElementChild.cloneNode(true);
            box.style.left   = (b.x*100)+'%';
            box.style.top    = (b.y*100)+'%';
            const w = (b.w ?? 0.25), h = (b.h ?? 0.12);
            box.style.width  = (w*100)+'%';
            box.style.height = (h*100)+'%';
            const contentEl = box.querySelector('.tb-content');
            if (contentEl) contentEl.textContent = b.text || '';
            box.dataset.annId = b.id;
            pageDiv.appendChild(box);
            enableBoxEditing(box, pageNum, b.id);
          }
        }catch(_){}
      }

      // ---------- Bootstrap ----------
      (async function init(){
        state.pdf = await pdfjsLib.getDocument(url).promise;
        state.total = state.pdf.numPages;
        hudSet(state.current || 1, state.total);

        for (let i=1; i<=state.pdf.numPages; i++){
          await renderPage(i);
        }

        const target = pagesHost.querySelector(`.pdf-page[data-page="${state.current || 1}"]`);
        if (target){
          const top = target.offsetTop - 24;
          scrollEl.scrollTo({ top, behavior: 'auto' });
        }

        await loadNoteFor(state.current || 1);

        scrollEl.addEventListener('scroll', onScroll, { passive: true });
        window.addEventListener('resize', debounce(onScroll, 150));

        setTool(TOOL.NONE);
      })();

      // Keyboard Undo (Ctrl/Cmd+Z)
      window.addEventListener('keydown', (e)=>{
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z'){
          e.preventDefault();
          doUndo();
        }
      });
    })();
    {% endif %}
  </script>
</body>
</html>