<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Limestone | Reading</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/reading.css') }}">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
</head>
<body>
  <!-- Fixed exit (same size as bookshelf icons, no shadow) -->
  <a class="exit-btn-fixed" href="{{ url_for('bookshelf') }}" title="Back to shelf">
    <img src="{{ url_for('static', filename='img/exit.png') }}" alt="Exit">
  </a>

  <div class="reader-shell">
    <!-- Top bar only across the middle reader column, no title text -->
<header class="topbar">
  <div class="bar-inner">
    <!-- leave implicit space for exit button at far left -->
    <button id="btnTextBox" class="tool-btn" title="Text box">
      <img src="{{ url_for('static', filename='img/text_box.png') }}" alt="T">
    </button>
    <button id="btnHighlighter" class="tool-btn" title="Highlighter">
      <img src="{{ url_for('static', filename='img/highlighter.png') }}" alt="Highlighter">
    </button>
    <button id="btnDrawer" class="tool-btn" title="Thin pen">
      <img src="{{ url_for('static', filename='img/drawer.png') }}" alt="Pen">
    </button>
  </div>
</header>

    <div class="layout">
      <!-- Ask AI (left quarter) -->
      <aside class="askai">
        <!-- response area stays transparent; pushed down so it never hides under exit -->
        <pre id="aiOut" class="ai-out"></pre>

        <!-- locked input at bottom-left -->
        <form id="aiForm" class="ai-form">
          <div class="ai-input">
            <input type="text" name="q" placeholder="Ask AI…" autocomplete="off">
            <button type="submit" class="icon-btn" title="Ask">
              <img src="{{ url_for('static', filename='img/search.png') }}" alt="Ask">
            </button>
          </div>
        </form>
      </aside>

      {% if file_url %}
      <!-- Middle half: digital reader -->
      <main class="book-area with-file">
        <div id="pdfScroll" class="pdf-scroll">
          <div id="pdfPages" class="pdf-pages"></div>
        </div>
        <form class="progress-bar" method="post" action="{{ url_for('update_progress', book_id=book.id) }}">
          <label>
            Page
            <input id="pageInput" type="number" name="page" min="0" value="{{ current_page or 0 }}" inputmode="numeric">
            {% if total_pages %}/ {{ total_pages }}{% endif %}
          </label>
          <button class="btn-save" type="submit">Save</button>
        </form>
      </main>
      {% else %}
      <!-- Middle half: physical book info -->
      <main class="book-area no-file">
        <div class="no-file-msg">
          <img class="cover-preview" src="{{ cover_url }}" alt="Cover">
          <p>This is a <b>Physical</b> book. Use the Notes pane to record pages and thoughts.</p>
          <form class="progress-bar" method="post" action="{{ url_for('update_progress', book_id=book.id) }}">
            <label>Page <input type="number" name="page" min="0" value="{{ current_page or 0 }}" inputmode="numeric"></label>
            <button class="btn-save" type="submit">Save</button>
          </form>
        </div>
      </main>
      {% endif %}

      <!-- Notes (right quarter) -->
      <aside class="notes{% if not file_url %} expanded{% endif %}">
        <div class="notes-page-num" id="notesPageLabel">
          Page {{ current_page or 0 }}
        </div>

        <!-- No “Add note” button; we upsert on page switch and manual autosave -->
        <form id="noteForm" class="note-form" method="post" action="{{ url_for('add_note', book_id=book.id) }}">
          <div class="row">
            <input class="note-title" type="text" name="title" placeholder="Title">
            <input class="note-page"  type="number" name="page" min="0" placeholder="Page #"
                  value="{{ current_page or 0 }}">
          </div>
          <textarea class="note-text" name="text" rows="6" placeholder="Enter text from here."></textarea>
        </form>

        <!-- No list — notes are per page and loaded in place -->
      </aside>
    </div>
  </div>

  <div id="pageHud" class="page-hud">– / –</div>

  <script>
    // Ask AI
    (function(){
      const f = document.getElementById('aiForm');
      const out = document.getElementById('aiOut');
      if (!f) return;
      f.addEventListener('submit', async (e) => {
        e.preventDefault();
        const fd = new FormData(f);
        out.textContent = 'Thinking…';
        try{
          const res = await fetch('{{ url_for("ask_ai") }}', { method:'POST', body:fd });
          const data = await res.json();
          out.textContent = data.ok ? data.answer : 'Error.';
        }catch(_){ out.textContent = 'Error.'; }
      });
    })();

    // Helpers shared by PDF + Notes
    function debounce(fn, ms){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms); }; }

    {% if file_url %}
    // PDF.js viewer + progress autosave + note page binding
    (function(){
      const pdfjsLib = window['pdfjs-dist/build/pdf'];
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

      const url = "{{ file_url }}";
      const pagesHost = document.getElementById('pdfPages');
      const scrollEl  = document.getElementById('pdfScroll');
      const hud       = document.getElementById('pageHud');
      const pageInput = document.getElementById('pageInput');

      // Notes form refs
      const noteForm = document.getElementById('noteForm');
      const noteTitle = noteForm.querySelector('.note-title');
      const notePage  = noteForm.querySelector('.note-page');
      const noteText  = noteForm.querySelector('.note-text');
      const pageLabel = document.getElementById('notesPageLabel');

      let pdf=null;
      let total={{ (total_pages or 'null') }};
      let current={{ (current_page or 0) }};
      let posting=false;

      let noteDirty = false;
      let activeNotePage = current || 0;

      function hudSet(p, t){ hud.textContent = t ? (p + ' / ' + t) : (String(p) + ' / –'); }
      function setLabel(p){ if (pageLabel){ pageLabel.textContent = 'Page ' + p; } }
      function setNotePage(p){ notePage.value = p; setLabel(p); }

      // ---- NOTES: load & save per page ----
      async function loadNoteFor(page){
        try{
          const q = new URLSearchParams({ page: String(page) });
          const res = await fetch(`/api/books/{{ book.id }}/notes/by_page?` + q.toString());
          const data = await res.json();
          if (data.ok){
            const n = data.note;
            noteTitle.value = n ? (n.title || '') : '';
            noteText.value  = n ? (n.text  || '') : '';
            noteDirty = false;
            activeNotePage = page;
            setNotePage(page);
          }
        }catch(_){}
      }

      async function saveNoteFor(page){
        if (!noteDirty) return;
        try{
          const payload = {
            page: page,
            title: noteTitle.value || '',
            text:  noteText.value  || ''
          };
          await fetch(`/api/books/{{ book.id }}/notes/upsert_by_page`, {
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body: JSON.stringify(payload)
          });
          noteDirty = false;
        }catch(_){}
      }

      noteTitle.addEventListener('input', ()=>{ noteDirty = true; });
      noteText .addEventListener('input', ()=>{ noteDirty = true; });

      // ---- PROGRESS: save + drive notes binding ----
      async function postProgress(p, t){
        if (posting) return;
        posting = true;
        try{
          await fetch(`/api/books/{{ book.id }}/progress`, {
            method: 'POST',
            headers: {'Content-Type':'application/json'},
            body: JSON.stringify({page: p, total: t})
          });
        }catch(_){}
        posting = false;
      }
      const postDebounced = debounce(postProgress, 350);

      function visiblePage(){
        const items = pagesHost.querySelectorAll('.pdf-page');
        let bestId = 1, bestRatio = -1;
        const vh = scrollEl.getBoundingClientRect();
        items.forEach(div => {
          const r = div.getBoundingClientRect();
          const overlapX = Math.max(0, Math.min(vh.right, r.right) - Math.max(vh.left, r.left));
          const overlapY = Math.max(0, Math.min(vh.bottom, r.bottom) - Math.max(vh.top, r.top));
          const area = overlapX * overlapY;
          const totalArea = r.width * r.height || 1;
          const ratio = area / totalArea;
          const id = parseInt(div.dataset.page, 10) || 1;
          if (ratio > bestRatio){ bestRatio = ratio; bestId = id; }
        });
        return bestId;
      }

      async function onScroll(){
        const p = visiblePage();
        if (p !== current){
          // save note for previous page (if dirty) BEFORE switching
          await saveNoteFor(activeNotePage);
          current = p;
          hudSet(current, total);
          if (pageInput) pageInput.value = current;
          postDebounced(current, total);
          // load note for the new page
          await loadNoteFor(current);
        }
      }

      function pageContainer(num){
        const wrap = document.createElement('div');
        wrap.className = 'pdf-page';
        wrap.dataset.page = String(num);
        wrap.style.position = 'relative';
        wrap.style.margin = '12px auto';
        wrap.style.background = '#fff';
        wrap.style.boxShadow = '0 2px 8px rgba(0,0,0,.12)';
        wrap.style.width = 'min(95%, 840px)';
        wrap.style.borderRadius = '4px';
        const canvas = document.createElement('canvas');
        canvas.style.display = 'block';
        canvas.style.width = '100%';
        canvas.style.height = 'auto';
        wrap.appendChild(canvas);
        return {wrap, canvas};
      }

      function renderPage(num){
        return pdf.getPage(num).then(page => {
          const {wrap, canvas} = pageContainer(num);
          pagesHost.appendChild(wrap);
          const viewport = page.getViewport({ scale: 1.5 });
          const context = canvas.getContext('2d');
          canvas.height = viewport.height;
          canvas.width  = viewport.width;
          return page.render({canvasContext: context, viewport}).promise;
        });
      }

      // Init
      (async function init(){
        const doc = await pdfjsLib.getDocument(url).promise;
        pdf = doc;
        total = pdf.numPages;
        hudSet(current || 1, total);

        // render sequentially to keep memory sane
        for (let i = 1; i <= pdf.numPages; i++){
          /* eslint-disable no-await-in-loop */
          await renderPage(i);
        }

        // scroll to last saved page if any
        const target = pagesHost.querySelector(`.pdf-page[data-page="${current || 1}"]`);
        if (target){
          const top = target.offsetTop - 24;
          scrollEl.scrollTo({ top, behavior: 'auto' });
        }

        // Load note for initial page
        await loadNoteFor(current || 1);

        scrollEl.addEventListener('scroll', onScroll, { passive: true });
        window.addEventListener('resize', debounce(onScroll, 150));
      })();
    })();
    {% endif %}

    // Minimal autosave when user manually edits the page number in the Notes pane
    (function(){
      const form = document.getElementById('noteForm');
      if (!form) return;
      const pageIn = form.querySelector('.note-page');
      const title  = form.querySelector('.note-title');
      const body   = form.querySelector('.note-text');
      const label  = document.getElementById('notesPageLabel');

      function setLabel(p){ if (label) label.textContent = 'Page ' + p; }

      pageIn.addEventListener('change', async ()=>{
        const p = parseInt(pageIn.value || '0', 10) || 0;
        setLabel(p);
        // Load the note for this manually selected page
        try{
          const q = new URLSearchParams({ page: String(p) });
          const res = await fetch(`/api/books/{{ book.id }}/notes/by_page?` + q.toString());
          const data = await res.json();
          if (data.ok){
            const n = data.note;
            title.value = n ? (n.title || '') : '';
            body.value  = n ? (n.text  || '') : '';
          }
        }catch(_){}
      });
    })();
  </script>
</body>
</html>