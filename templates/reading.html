<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Limestone | Reading</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/reading.css') }}">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
</head>
<body>
  <!-- Fixed exit (same size as bookshelf icons, no shadow) -->
  <a class="exit-btn-fixed" href="{{ url_for('bookshelf') }}" title="Back to shelf">
    <img src="{{ url_for('static', filename='img/exit.png') }}" alt="Exit">
  </a>

  <div class="reader-shell">
    <!-- Top bar only across the middle reader column, no title text -->
    <header class="topbar"><div class="bar-inner"></div></header>

    <div class="layout">
      <!-- Ask AI (left quarter) -->
      <aside class="askai">
        <!-- response area stays transparent; pushed down so it never hides under exit -->
        <pre id="aiOut" class="ai-out"></pre>

        <!-- locked input at bottom-left -->
        <form id="aiForm" class="ai-form">
          <div class="ai-input">
            <input type="text" name="q" placeholder="Ask AI…" autocomplete="off">
            <button type="submit" class="icon-btn" title="Ask">
              <img src="{{ url_for('static', filename='img/search.png') }}" alt="Ask">
            </button>
          </div>
        </form>
      </aside>

      {% if file_url %}
      <!-- Middle half: digital reader -->
      <main class="book-area with-file">
        <div id="pdfScroll" class="pdf-scroll">
          <div id="pdfPages" class="pdf-pages"></div>
        </div>
        <form class="progress-bar" method="post" action="{{ url_for('update_progress', book_id=book.id) }}">
          <label>
            Page
            <input id="pageInput" type="number" name="page" min="0" value="{{ current_page or 0 }}" inputmode="numeric">
            {% if total_pages %}/ {{ total_pages }}{% endif %}
          </label>
          <button class="btn-save" type="submit">Save</button>
        </form>
      </main>
      {% else %}
      <!-- Middle half: physical book info -->
      <main class="book-area no-file">
        <div class="no-file-msg">
          <img class="cover-preview" src="{{ cover_url }}" alt="Cover">
          <p>This is a <b>Physical</b> book. Use the Notes pane to record pages and thoughts.</p>
          <form class="progress-bar" method="post" action="{{ url_for('update_progress', book_id=book.id) }}">
            <label>Page <input type="number" name="page" min="0" value="{{ current_page or 0 }}" inputmode="numeric"></label>
            <button class="btn-save" type="submit">Save</button>
          </form>
        </div>
      </main>
      {% endif %}

      <!-- Notes (right quarter) -->
      <aside class="notes{% if not file_url %} expanded{% endif %}">
        <div class="notes-page-num" id="notesPageLabel">
          Page {{ current_page or 0 }}
        </div>

        <form id="noteForm" class="note-form" method="post" action="{{ url_for('add_note', book_id=book.id) }}">
          <div class="row">
            <input class="note-title" type="text" name="title" placeholder="Title">
            <input class="note-page"  type="number" name="page" min="0" placeholder="Page #" value="{{ current_page or 0 }}">
          </div>
          <textarea class="note-text" name="text" rows="6" placeholder="Enter text from here."></textarea>
          <!-- no Add button; autosaves on scroll -->
        </form>

        <div id="noteList" class="note-list">
          {% for n in book.notes|sort(attribute='created_at', reverse=True) %}
            <article class="note">
              <header>
                <div class="ttl">{{ n.title or 'Untitled' }}</div>
                {% if n.page is not none %}<div class="pg">p. {{ n.page }}</div>{% endif %}
                <form method="post" action="{{ url_for('delete_note', note_id=n.id) }}">
                  <button class="link danger" type="submit">Delete</button>
                </form>
              </header>
              {% if n.text %}<div class="txt">{{ n.text }}</div>{% endif %}
              <footer class="ts">{{ n.created_at.strftime('%Y-%m-%d %H:%M') }}</footer>
            </article>
          {% else %}
            <p class="empty" id="notesEmpty">No notes yet.</p>
          {% endfor %}
        </div>
      </aside>
    </div>
  </div>

  <div id="pageHud" class="page-hud">– / –</div>

  <script>
    // Ask AI
    (function(){
      const f = document.getElementById('aiForm');
      const out = document.getElementById('aiOut');
      if (!f) return;
      f.addEventListener('submit', async (e) => {
        e.preventDefault();
        const fd = new FormData(f);
        out.textContent = 'Thinking…';
        try{
          const res = await fetch('{{ url_for("ask_ai") }}', { method:'POST', body:fd });
          const data = await res.json();
          out.textContent = data.ok ? data.answer : 'Error.';
        }catch(_){ out.textContent = 'Error.'; }
      });
    })();

    {% if file_url %}
    // PDF.js viewer + progress autosave
    (function(){
      const pdfjsLib = window['pdfjs-dist/build/pdf'];
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

      const url = "{{ file_url }}";
      const pagesHost = document.getElementById('pdfPages');
      const scrollEl  = document.getElementById('pdfScroll');
      const hud       = document.getElementById('pageHud');
      const pageInput = document.getElementById('pageInput');

      let pdf=null;
      let total={{ (total_pages or 'null') }};
      let current={{ (current_page or 0) }};
      let posting=false;

      function hudSet(p,t){ hud.textContent = t ? (p+' / '+t) : (String(p)+' / –'); }
      function debounce(fn,ms){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms); }; }
      async function postProgress(p,t){
        if (posting) return; posting=true;
        try{
          await fetch(`/api/books/{{ book.id }}/progress`, {
            method:'POST', headers:{'Content-Type':'application/json'},
            body: JSON.stringify({ page:p, total:t })
          });
        }catch(_){}
        posting=false;
      }
      const postDebounced = debounce(postProgress, 350);

      function visiblePage(){
        const items = pagesHost.querySelectorAll('.pdf-page');
        let bestId=1,best=-1;
        const vh = scrollEl.getBoundingClientRect();
        items.forEach(div=>{
          const r=div.getBoundingClientRect();
          const ox=Math.max(0, Math.min(vh.right,r.right)-Math.max(vh.left,r.left));
          const oy=Math.max(0, Math.min(vh.bottom,r.bottom)-Math.max(vh.top,r.top));
          const area=ox*oy, totalArea=r.width*r.height||1;
          const ratio=area/totalArea, id=parseInt(div.dataset.page,10)||1;
          if(ratio>best){ best=ratio; bestId=id; }
        });
        return bestId;
      }

      function onScroll(){
        const p = visiblePage();
        if (p !== current){
          current = p;
          hudSet(current, total);
          if (pageInput) pageInput.value = current;
          postDebounced(current, total);
        }
      }

      function pageContainer(num){
        const wrap=document.createElement('div');
        wrap.className='pdf-page';
        wrap.dataset.page=String(num);
        wrap.style.position='relative';
        wrap.style.margin='12px auto';
        wrap.style.background='#fff';
        wrap.style.boxShadow='0 2px 8px rgba(0,0,0,.12)';
        wrap.style.width='min(95%, 840px)';
        wrap.style.borderRadius='4px';
        const canvas=document.createElement('canvas');
        canvas.style.display='block';
        canvas.style.width='100%';
        canvas.style.height='auto';
        wrap.appendChild(canvas);
        return {wrap,canvas};
      }

      function renderPage(num){
        return pdf.getPage(num).then(page=>{
          const {wrap,canvas}=pageContainer(num);
          pagesHost.appendChild(wrap);
          const viewport=page.getViewport({ scale:1.5 });
          const ctx=canvas.getContext('2d');
          canvas.height=viewport.height; canvas.width=viewport.width;
          return page.render({ canvasContext:ctx, viewport }).promise;
        });
      }

      pdfjsLib.getDocument(url).promise.then(async _pdf=>{
        pdf=_pdf;
        total=pdf.numPages;
        hudSet(current||1,total);
        postDebounced(current||1,total);

        for(let i=1;i<=pdf.numPages;i++){ /* eslint-disable-line no-await-in-loop */
          await renderPage(i);
        }

        const target = pagesHost.querySelector(`.pdf-page[data-page="${current||1}"]`);
        if (target){
          const top = target.offsetTop - 24;
          scrollEl.scrollTo({ top, behavior:'auto' });
        }

        scrollEl.addEventListener('scroll', onScroll, { passive:true });
        window.addEventListener('resize', debounce(onScroll,150));
      });
    })();
    {% endif %}

    // Notes: autosave on scroll; transparent fields; live page label + count
    (function(){
      const form   = document.getElementById('noteForm');
      if (!form) return;

      const list   = document.getElementById('noteList');
      const empty  = document.getElementById('notesEmpty');
      const pageIn = form.querySelector('.note-page');
      const title  = form.querySelector('.note-title');
      const body   = form.querySelector('.note-text');
      const label  = document.getElementById('notesPageLabel');

      let lastSent = '';
      let saving   = false;

      function updateLabel(){
        if (label && pageIn) label.textContent = 'Page ' + (pageIn.value || '0');
      }
      pageIn && pageIn.addEventListener('input', updateLabel);
      updateLabel();

      function updateCount(){
        const count = list ? list.querySelectorAll('.note').length : 0;
        if (empty){
          if (count > 0) { empty.style.display='none'; }
          else { empty.style.display=''; empty.textContent='No notes yet.'; }
        }
      }
      updateCount();

      function contentKey(){
        return [pageIn?.value||'', title?.value||'', body?.value||''].join('\n---\n');
      }

      async function autosave(){
        const key = contentKey().trim();
        if (!key || key === lastSent) return;
        if (saving) return;
        saving = true;
        try{
          const fd = new FormData(form);
          await fetch(form.action, { method:'POST', body: fd });
          lastSent = key;
        }catch(_){/* silent */}
        saving = false;
      }

      const onScrollSave = (e)=>{
        // Only react to scrolls occurring inside the Notes pane
        const pane = e.target.closest && e.target.closest('.notes');
        if (pane) autosave();
      };
      document.addEventListener('scroll', onScrollSave, { passive:true, capture:true });
    })();
  </script>
</body>
</html>